#cs ----------------------------------------------------------------------------

 AutoIt Version: 3.3.14.2
 Author:         RattletraPM

 Script Function:
	A nice [citation needed] GUI for DetermiToolkit. It also provides other
	handy functions aswell.

	Part of DetermiToolkit (former UDTranslation Kit).

	This script has been commented in english so that other translators will be
	able to understand how it works and modify it to their own needs.

#ce ----------------------------------------------------------------------------

;Includes needed for the GUI to work
#include <ButtonConstants.au3>
#include <ComboConstants.au3>
#include <EditConstants.au3>
#include <GUIConstantsEx.au3>
#include <GUIListBox.au3>
#include <WindowsConstants.au3>

;Includes needed for other parts of the script to work
#include <File.au3>
#include <String.au3>
#include <MsgBoxConstants.au3>
#include <AutoItConstants.au3>

Opt("TrayIconHide",1)	;This script doesn't need the tray icon at all

;AutoIt includes a trailing backslash to @ScriptDir only when the script is run on the root of a drive,
;so we need to check if this is the case before doing anything as it could cause errors later on.
If StringRight(@ScriptDir,1)<>"\" Then
	$currentdir=@ScriptDir&"\"	;If the string doesn't have a current backslash, add it
Else
	$currentdir=@ScriptDir		;If it does, keep it that way
EndIf

;Constants
Const $guititledefault="DetermiToolkit"
Const $dtVer="0.4b"	;DetermiToolkit version
Const $strgdir=$currentdir&"res\STRG\"
Const $metadataini=$strgdir&"metadata.ini"	;metadata.ini file
Const $inifiledir=$currentdir&"res\DTConfig.ini"	;DetermiToolkit INI config file
Const $definstalldir=@ProgramFilesDir&"\Steam\steamapps\common\Undertale\data.win"

;The program checks if DTConfig.ini exists. If it doesn't then it means that it's probably the first time that the user runs DetermiToolkit.
If FileExists($inifiledir)==0 Then
	;So, we first check if res\STRG is empty. If it is, then we ask the user to either extract the strings from data.win or import a TranslaTale project
	If CheckSTRGEmpty()==1 Then
		Local $firstchoice=MsgBox(BitOr($MB_SYSTEMMODAL,$MB_YESNO,$MB_ICONINFORMATION),$guititledefault&" - Welcome!","It looks like this is the first time you're using DetermiToolkit!"&@CRLF&"To get started you either need to extract the strings from your Undertale's data.win file or import a TranslaTale project."&@CRLF&@CRLF&"Choose Yes to extract the strings or No to import a TranslaTale project.")

		;If the user answers yes, we will extract the strings from data.win
		If $firstchoice==$IDYES Then
			MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONINFORMATION),$guititledefault,"Alright, then! I'll try to locate the data.win file by looking at Undertale's default Steam installation directory."&@CRLF&"If this check fails then you'll need to specify the data.win file's location by yourself.")
			;First, we check if data.win exists inside the default Steam installation directory for Undertale
			If FileExists($definstalldir) Then
				IniWrite($inifiledir, "DetermiToolkitCFG", "datawin", $definstalldir)
				;If the string extraction fails, exit
				If ExtractStringsGUI()==0 Then
					Exit
				EndIf
			;If data.win doesn't exist in $definstalldir, the user must locate it before we can continue
			Else
				MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONWARNING),$guititledefault,"I couldn't find data.win inside Undertale's default Steam install directory (this is to be expected if you've changed your Steam/Undertale install dir or if you own a DRM-free version of the game)."&@CRLF&@CRLF&"You'll have to locate the data.win file manually.")
				If WriteINICFG()=="" Then
					Exit
				EndIf
				;See above
				If ExtractStringsGUI()==0 Then
					Exit
				EndIf
			EndIf
		;TODO: If the user chooses to import a TranslaTale project
		Else
			PlaceholderFunc()
			Exit 414141
		EndIf
	EndIf
ElseIf IniRead($inifiledir,"DetermiToolkitCFG","clean",0)==1 Then
	DirRemove($strgdir,1)
	If ExtractStringsGUI()==0 Then
		Exit
	EndIf
	IniWrite($inifiledir, "DetermiToolkitCFG", "clean", "0")
EndIf

;Global variables
Global $fArray=_FileListToArray($strgdir,"*.bin",1)	;Array containing all the filenames for the strings
Global $DTPageNum=0		;Var that controls the current page shown by the GUI
Global $DTTotalPages=$fArray[0]/1000	;Once we've got the total number of pages, we'll store it here so we no longer need to call _FileListToArray
Global $curstring=Null	;Currently selected string

;The following piece of code is the acutal GUI generated by Koda form designer. If you want to mod the GUI
;in any way, just open DTForm.kxf in Koda, mod it as you wish, generate the code and overwrite whatever is
;in this block (remember to edit the includes above and to NOT overwrite the GUI loop below!)
;
;The parts that have been modified in some way after being generated have been commented
#Region ### START Koda GUI section ### Form=c:\users\rattletrapm\desktop\undertale\determitoolkit source\gui\dtform.kxf
$DTForm = GUICreate($guititledefault, 498, 365, 236, 159)	;Changed to $guititledefault so we can modify the title & restore it at will
$DTMenuFile = GUICtrlCreateMenu("&File")
$MenuItem4 = GUICtrlCreateMenuItem("Choose Undertale data.win", $DTMenuFile)
$MenuItem12 = GUICtrlCreateMenuItem("Import strings from TranslaTale", $DTMenuFile)
$MenuItem13 = GUICtrlCreateMenuItem("Export strings to TranslaTale", $DTMenuFile)
$MenuItem5 = GUICtrlCreateMenuItem("Exit", $DTMenuFile)
$MenuItem2 = GUICtrlCreateMenu("&Edit")
$MenuItem6 = GUICtrlCreateMenuItem("Search for strings", $MenuItem2)
$MenuItem1 = GUICtrlCreateMenu("&Bookmarks")
$MenuItem8 = GUICtrlCreateMenuItem("Export bookmarks", $MenuItem1)
$MenuItem9 = GUICtrlCreateMenuItem("Import bookmarks", $MenuItem1)
$MenuItem15 = GUICtrlCreateMenu("&Tools")
$MenuItem3 = GUICtrlCreateMenuItem("Re-extract strings from data.win", $MenuItem15)
$MenuItem16 = GUICtrlCreateMenuItem("Insert strings in data.win", $MenuItem15)
$MenuItem10 = GUICtrlCreateMenu("&About")
$MenuItem11 = GUICtrlCreateMenuItem("About DetermiToolkit "&$dtVer, $MenuItem10) ;##VER_NUM## changed to $dtVer
$DTStrGroup = GUICtrlCreateGroup("Strings", 8, 0, 169, 337)
$DTStringList = GUICtrlCreateList("", 16, 16, 153, 253, BitOR($LBS_NOTIFY,$LBS_HASSTRINGS,$WS_VSCROLL,$WS_BORDER))
$DTBtnPrevPage = GUICtrlCreateButton("<<", 16, 272, 41, 25)
$DTPageView = GUICtrlCreateLabel("...", 64, 280, 65, 17)	;Changed text to "..." as we'll use GUICtrlSetData to get the current page number
$DTBtnNextPage = GUICtrlCreateButton(">>", 128, 272, 41, 25)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$DTStringBtnGoto = GUICtrlCreateButton("Go to", 136, 304, 33, 25)
$DTStringGotoEdit = GUICtrlCreateInput("Insert string number", 16, 304, 121, 21)
$DTBookmarkGroup = GUICtrlCreateGroup("Bookmarks", 184, 0, 305, 49)
$DTComboBoxBookmarkList = GUICtrlCreateCombo("Select Bookmark list", 192, 16, 121, 25, BitOR($CBS_DROPDOWN,$CBS_AUTOHSCROLL))
$DTComboBoxBookmarks = GUICtrlCreateCombo("Select Bookmark", 320, 16, 121, 25, BitOR($CBS_DROPDOWN,$CBS_AUTOHSCROLL))
GUICtrlCreateGroup("", -99, -99, 1, 1)
$DTEditToolsGroup = GUICtrlCreateGroup("Editing tools", 184, 56, 305, 81)
$DTComboBoxTextCol = GUICtrlCreateCombo("Choose text color", 192, 72, 161, 25, BitOR($CBS_DROPDOWN,$CBS_AUTOHSCROLL))
$DTBtnAddCol = GUICtrlCreateButton("Add color escape code", 360, 72, 121, 25)
$DTComboBoxAddEscCode = GUICtrlCreateCombo("Other escape codes", 192, 104, 161, 25, BitOR($CBS_DROPDOWN,$CBS_AUTOHSCROLL))
$DTBtnAddEscCode = GUICtrlCreateButton("Add misc escape code", 360, 104, 121, 25)
GUICtrlCreateGroup("", -99, -99, 1, 1)
$DTBtnBookmarkGo = GUICtrlCreateButton("Go!", 448, 16, 35, 25)
$DTStringEdit = GUICtrlCreateEdit("", 184, 144, 305, 153, BitOR($GUI_SS_DEFAULT_EDIT,$WS_BORDER))
GUICtrlSetData(-1, "Choose a string!")	;"DTStringEdit" changed to "Choose a string!"
$DTBtnSave = GUICtrlCreateButton("Save", 416, 304, 73, 33)
$DTBtnAddBookmark = GUICtrlCreateButton("Add Bookmark", 184, 304, 97, 33)
$DTBtnRmBookmark = GUICtrlCreateButton("Remove Bookmark", 288, 304, 105, 33)
GUISetState(@SW_SHOW)
#EndRegion ### END Koda GUI section ###

GenerateStringPreviews()

;!!! - Doesn't belong here, but we can use this to read the currently selected item in the string list - !!!
;MsgBox(0,0,GUICtrlRead($DTStringList))
;!!! - Doesn't belong here, but we can use this to set the currently selected item in the string list - !!!
;_GUICtrlListBox_SetCurSel($DTStringList,999)

;While loop, used to keep the GUI open
While 1
	;Gets the current GUI Msg, used to determine which control the user has interacted with
	$nMsg = GUIGetMsg()
	Switch $nMsg
		;"Next page" button
		Case $DTBtnNextPage
			;Check if the maximum page number has been reached
			If $DTPageNum+1<$DTTotalPages Then
				GUICtrlSetData($DTStringList,"")	;Empty the string list
				$DTPageNum+=1	;Add 1 to the current page variable
				GenerateStringPreviews()	;Generate new string previews
			EndIf
		;"Previous page" button
		Case $DTBtnPrevPage
			;Check if the minimum page number has been reached
			If $DTPageNum-1>=0 Then
				GUICtrlSetData($DTStringList,"")	;Empty the string list
				$DTPageNum-=1	;Subtracts 1 to the current page variable
				GenerateStringPreviews()	;Generate new string previews
			EndIf
		;"Goto" button
		Case $DTStringBtnGoto
			StringGoto()
		Case $DTBtnSave
			If $curstring<>Null Then
				SaveString(GUICtrlRead($DTStringEdit),$curstring)
				GUICtrlSetData($DTStringList,"")	;Empty the string list
				GenerateStringPreviews()
				_GUICtrlListBox_SetCurSel($DTStringList,_GUICtrlListBox_FindInText($DTStringList,StringFormat("%05d",$curstring)&" - "))	;Select the string
			EndIf
		;"File->Choose Undertale data.win"
		Case $MenuItem4
			WriteINICFG()
		;"File->Import strings from TranslaTale" - all the choices with placeholder functions have their own cases because in the next versions they'll have different functions
		Case $MenuItem12
			PlaceholderFunc()
		;"File->Export strings to TranslaTale"
		Case $MenuItem13
			PlaceholderFunc()
		;"Edit->Search for strings"
		Case $MenuItem6
			StringSearch()
		;"Bookmarks->Export bookmarks"
		Case $MenuItem8
			PlaceholderFunc()
		;"Bookmarks->Import bookmarks"
		Case $MenuItem9
			PlaceholderFunc()
		;"Tools->Re-extract strings from data.win"
		Case $MenuItem3
			Local $confirm=MsgBox(BitOr($MB_SYSTEMMODAL,$MB_YESNO,$MB_ICONWARNING),$guititledefault,"WARNING: This will OVERWRITE all the strings, you WILL LOSE ALL YOUR CHANGES! Are you sure you want to do this?")

			If $confirm==$IDYES Then
				IniWrite($inifiledir, "DetermiToolkitCFG", "clean", "1")
				Run(@ScriptFullPath)
				Exit
			EndIf
		;"Tools->Insert strings in data.win"
		Case $MenuItem16
			If IniRead($inifiledir, "DetermiToolkitCFG", "dialoginsert",0)==0 Then
				Local $confirmovr=MsgBox(BitOr($MB_SYSTEMMODAL,$MB_YESNO,$MB_ICONWARNING),$guititledefault,"WARNING: This will OVERWRITE your data.win file."&@CRLF&"If you didn't backup your data.win file, DO IT NOW."&@CRLF&@CRLF&"Are you sure you want to do this? (If you choose yes, this dialog won't be shown again)")

				If $confirmovr==$IDYES Then
					IniWrite($inifiledir, "DetermiToolkitCFG", "dialoginsert", 1)
					RunWait($currentdir&"bin\DTImport.exe","")
				EndIf
			Else
				RunWait($currentdir&"bin\DTImport.exe","")
			EndIf
		;"About->About DetermiToolkit"
		Case $MenuItem11
			MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONINFORMATION),$guititledefault,"-DetermiToolkit v"&$dtVer&"-"&@CRLF&"by RattletraPM"&"NOTE: This program is unofficial and has no affiliation to Toby Fox.")
		;"Close window" button
		Case $GUI_EVENT_CLOSE
			Exit
		;"File->Close". It needs to have its own case or the GUI will close immediately
		Case $MenuItem5
			Exit
	EndSwitch

	Local $listsel=Number(StringLeft(GUICtrlRead($DTStringList),5))
	;If a string has been selected and it isn't the same as $curstring
	If GUICtrlRead($DTStringList)<>"" And $curstring<>$listsel Then
		;Read that string
		GUICtrlSetData($DTStringEdit,ReadString($listsel))
		$curstring=$listsel
	EndIf
WEnd

;Searches for a string
Func StringSearch()
	Local $searchstr=_StringToHex(InputBox($guititledefault,"String to search for? (Case sensitive)"&@CRLF&@CRLF&"WARNING: Escape codes are INCLUDED in the search, so try to keep the search as small as possible unless you know EXACTLY what to look for."))
	Local $i=0
	Local $success=0

	If $searchstr<>"" Then
		Do
			Local $hfile=FileOpen($strgdir&$i&".bin", $FO_BINARY)
			Local $sfile=String(FileRead($hfile))

			If StringInStr($sfile,$searchstr)<>0 Then
				Local $yesno=MsgBox(BitOr($MB_SYSTEMMODAL,$MB_YESNO,$MB_ICONINFORMATION),$guititledefault,"String #"&$i&@CRLF&ReadString($i)&@CRLF&"Is this the string you were looking for?")
				If $yesno==$IDYES Then
					GUICtrlSetData($DTStringGotoEdit,$i)
					StringGoto()
					$success=1
					ExitLoop
				EndIf
			EndIf
			$i+=1
			_ReduceMemory()
		Until $i==$fArray[0]
		If $success==0 Then
			MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONWARNING),$guititledefault,"String not found.")
		EndIf
	EndIf
EndFunc

;Used by the "go to" button to go to a specific string. Also used by the string search function to go to a specific string
Func StringGoto()
	Local $numbgoto=GUICtrlRead($DTStringGotoEdit)

	If StringIsDigit($numbgoto) Then	;Check if the string is made out of digits only
		If $numbgoto>=0 And $numbgoto<=$fArray[0]-1 Then	;Check if $numbgoto is smaller than the total number of strings and greater than 0 (this last one shouldn't be needed, as "-" is seen as a non-number)
			GUICtrlSetData($DTStringList,"")	;Empty the string list
			$DTPageNum=Floor($numbgoto/1000)	;Calculate the string's page by dividing the number by 1000 and flooring it
			GenerateStringPreviews()			;Generate new string previews
			_GUICtrlListBox_SetCurSel($DTStringList,_GUICtrlListBox_FindInText($DTStringList,StringFormat("%05d",$numbgoto)&" - "))	;Select the string
		Else
			MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONWARNING),$guititledefault,"The requested string cannot be found (out of bounds).")
		EndIf
	Else
		MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONWARNING),$guititledefault,"Insert a valid number (digits only).")
	EndIf
EndFunc

;Reads the string $num. If $len is greater than 0, it will return only a number of characters from said string
Func ReadString($num,$len = 0)
	Local $FilePath=$strgdir&String($num)&".bin"
	Local $hStrgFile=FileOpen($FilePath,BitOr($FO_BINARY,$FO_READ))

	;Error handling - if FileOpen returned -1 it means that the file couldn't be read
	If $hStrgFile==-1 Then
		MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONERROR),$guititledefault&" - CRITICAL ERROR","INTERNAL ERROR"&@CRLF&"String #"&$num&" couldn't be opened.")
		Exit
	EndIf

	;A pretty nasty bug happens if we try to set the file pos when we're reading an empty file
	;We need to check for that first
	If FileGetSize($FilePath)>0 Then
		FileSetPos($hStrgFile,4,$FILE_BEGIN)
	EndIf
	;Read the string and convert it to ASCII characters.
	;We need to subtract -5 to FileGetSize as we don't need to count the 4 lenght bytes + the terminator byte
	$strgread=_HexToString(FileRead($hStrgFile,FileGetSize($FilePath)-5))
	FileClose($FilePath)
	Switch $len
		;If $len is equal to 0 it means that we need to read the whole string
		Case 0
			Return $strgread
		;If $len is greater than 0 we need to return $len characters from the string we've just read
		Case $len>0
			If StringLen($strgread)>=$len Then
				Return StringLeft($strgread,$len)
			Else
				;Error handling - if $len is greater than the string's lenght then something went wrong
				MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONERROR),$guititledefault&" - CRITICAL ERROR","INTERNAL ERROR"&@CRLF&"The program tried to return less characters than there were in string #"&$num&".")
				Exit 10
			EndIf
		;Error handling - if $len is smaller than 0 then something went wrong
		Case $len<0
			MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONERROR),$guititledefault&" - CRITICAL ERROR","INTERNAL ERROR"&@CRLF&"The program tried to return a negative number of characters from string #"&$num&".")
			Exit
		;Error handling - if $len is not a number then something went wrong
		Case Else
			MsgBox(BitOr($MB_SYSTEMMODAL,$MB_ICONERROR),$guititledefault&" - CRITICAL ERROR","INTERNAL ERROR"&@CRLF&"Malformed call to read string #"&$num&".")
			Exit
	EndSwitch
EndFunc

;Generates a binary string ready to be re-injected inside the data.win file
Func SaveString($str,$strgnum)
	Local $hexstring="0x"&ByteReverse(Hex(StringLen($str),8))&_StringToHex($str)&"00"
	Local $stringfile=FileOpen($strgdir&$strgnum&".bin",BitOr($FO_BINARY,$FO_OVERWRITE))

	FileWrite($stringfile,Binary($hexstring))
	FileClose($stringfile)
EndFunc

;This function generates string previews for the string list
Func GenerateStringPreviews()
	;Change the sting that tells the user which page he is currently viewing
	;Notice how we need to ad 1 to $DTPageNum as that variable is 0-based
	GUICtrlSetData($DTPageView, "Page "&$DTPageNum+1&"/"&Ceiling($fArray[0]/1000))
	$i=1000*$DTPageNum
	Do
		Local $FilePath=$strgdir&$i&".bin"

		;If the string is too long to get shown entirely in the list, truncate it and add "..."
		If FileGetSize($FilePath)-5>15 Then
			$strgread=ReadString($i,12)&"..."
		Else
			$strgread=ReadString($i)
		EndIf
		_GUICtrlListBox_AddString($DTStringList,StringFormat("%05d",$i)&" - "&$strgread)
		$i+=1
	Until $i==1000*($DTPageNum+1) Or $i==$fArray[0]
	;Repeated calls of this function will increase memory usage a lot, so we'll call this function
	_ReduceMemory()
EndFunc

;Checks if res\STRG is empty. Returns 1 if it is.
;I've made this a separate function to reduce code redundancy
Func CheckSTRGEmpty()
	Local $dirempty=DirGetSize($strgdir,1)
	If @error<>0 Or $dirempty[1]==0 Then
		Return 1
	EndIf
EndFunc

;Writes the INI file used as a configuration file.
;I've made this a separate function to reduce code redundancy
Func WriteINICFG()
	Local $dir=FileOpenDialog("Select UNDERTALE's data.win file", @ScriptDir, "GM:S data file (data.win)", $FD_FILEMUSTEXIST)

	FileChangeDir(@ScriptDir)	;FileOpenDialog changes the working directory, so we need to change it back to avoid bugs and nasty stuff
	If $dir<>"" Then
		IniWrite($inifiledir, "DetermiToolkitCFG", "datawin", $dir)
	EndIf

	Return $dir
EndFunc

;This function uses DTExtract (a modified, better version of the old DetermiToolkit_ExtracTest) to extract the strings from data.win.
;In the future I might incorporate DTExtract directly inside this program so that error handling will be a lot easier
Func ExtractStringsGUI()
	;First of all, check if DTExtract exists
	If FileExists($currentdir&"bin\DTExtract.exe")==0 Then
		MsgBox(BitOr($MB_ICONERROR,$MB_SYSTEMMODAL),$guititledefault&" - CRITICAL ERROR","Couldn't find DTExtract.exe in the BIN directory!")
		Return 0
	EndIf

	;Run DTExtract. We'll store the PID in $hRun for error handling purposes
	Local $hRun=Run($currentdir&"bin\DTExtract.exe","",@SW_HIDE)
	If $hRun==0 Then
		MsgBox(BitOr($MB_ICONERROR,$MB_SYSTEMMODAL),$guititledefault&" - CRITICAL ERROR","Couldn't run DTExtract.exe!")
		Return 0
	EndIf
	;Create a progress bar so that the user knows what's going on
	ProgressOn($guititledefault&" - Extracting strings...", "Extracting strings...", "Retrieving metadata...", Default, Default, BitOr($DLG_NOTONTOP,$DLG_MOVEABLE))
	;Loop until DTExtract has created succesfully the metadata.ini file, so that this program can know exactly how many strings we'll have to extract
	Do
		;In case DTExtract encounters an error or crashes, we want to delete everything inside $strgdir so that it'll be clean from a partial extraction
		If ProcessExists($hRun)==0 Then
			MsgBox(BitOr($MB_ICONERROR,$MB_SYSTEMMODAL),$guititledefault&" - CRITICAL ERROR","DTExtract.exe closed unexpectedly!")
			DirRemove($strgdir,$DIR_REMOVE)
			Return 0
		EndIf
		Sleep(50)
	Until FileExists($metadataini)==1
	;This is here to avoid a nasty bug - if we'll try to read the metadata.ini file right away we'll only get a blank string as the script writes other data before
	;writing the number of strings to the file (not to mention, if we use _FileListToArray while no bin files are there the script will crash as it won't return an array
	;but only a blank string)
	;So, instead of going on with the script straight away, we'll wait until there's at least one bin file
	Local $fArray=_FileListToArray($strgdir,Default,1)
		If $fArray[0]<=2 Then
			Do
				$fArray=_FileListToArray($strgdir,Default,1)
				Sleep(50)
			Until $fArray[0]>2
		EndIf
	;Now we can read the string number from data.ini and loop until all the bin files are generated
	Do
		Local $strgnumdec=Dec(IniRead($metadataini,"Metadata","StrgNum",0))
		$fArray=_FileListToArray($strgdir,"*.bin",1)
		Local $percent=Round(($fArray[0]/$strgnumdec)*100)								;Calculate the percentage
		ProgressSet($percent, "Extracting strings... ("&$farray[0]&"/"&$strgnumdec&")")	;We'll modify the text inside the window to show that we're extracting the strings now
		Sleep(50)
		;Same as before, in case DTExtract crashes, empty $strgdir
		If ProcessExists($hRun)==0 And $percent<>100 Then
			MsgBox(BitOr($MB_ICONERROR,$MB_SYSTEMMODAL),$guititledefault&" - CRITICAL ERROR","DTExtract.exe closed unexpectedly!")
			DirRemove($strgdir,$DIR_REMOVE)
			Return 0
		EndIf
	Until $percent==100
	ProgressOff()
	Return 1
EndFunc

Func ByteReverse($instr)	;Function used to reverse bytes of a given string
	Local $ret, $i
	Local $len = StringLen($instr)/2

	If StringIsFloat($len) == 1 Then		;If $instr's lenght can't be divided by 2, it means that something went wrong
		Return -1
	EndIf
	Do
		$ret=$ret&StringRight($instr,2)		;Get the last byte and place it at the end of the newly formed string...
		$instr=StringTrimRight($instr,2)	;...delete that byte from the original string...
		$i+=1								;...increase the index value by one...
	Until $i==$len							;...and repeat for each byte in $instr
	Return $ret
EndFunc

; Reduce memory usage
; Author wOuter ( mostly )
Func _ReduceMemory($i_PID = -1)

    If $i_PID <> -1 Then
        Local $ai_Handle = DllCall("kernel32.dll", 'int', 'OpenProcess', 'int', 0x1f0fff, 'int', False, 'int', $i_PID)
        Local $ai_Return = DllCall("psapi.dll", 'int', 'EmptyWorkingSet', 'long', $ai_Handle[0])
        DllCall('kernel32.dll', 'int', 'CloseHandle', 'int', $ai_Handle[0])
    Else
        Local $ai_Return = DllCall("psapi.dll", 'int', 'EmptyWorkingSet', 'long', -1)
    EndIf

    Return $ai_Return[0]
EndFunc;==> _ReduceMemory()

;Function that acts as a placeholder
Func PlaceholderFunc()
	MsgBox(0,0,"This is the SCRIPT'S NOT DONE YET song~~"&@CRLF&"The script hasn't been written yet, so here's this song~~"&@CRLF&"I'm gonna close now, so I won't crash~~"&@CRLF&"Bye bye and see you the next time!~~")
EndFunc